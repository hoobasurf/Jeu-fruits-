<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Jeu Fruits/Légumes - Descente Animée & Interdits</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background: #f0fafb;
    margin: 20px;
    text-align: center;
    user-select: none;
  }
  h1 {
    color: #00695c;
  }
  #objective {
    margin: 15px 0;
    font-size: 18px;
    color: #004d40;
  }
  #forbidden {
    margin: 10px 0;
    font-weight: bold;
    color: #d32f2f;
  }
  #grid {
    display: grid;
    grid-template-columns: repeat(6, 70px);
    grid-gap: 8px;
    justify-content: center;
    margin: 20px auto;
    position: relative;
    user-select: none;
    /* relative pour position absolue des images animées */
  }
  .cell {
    width: 70px;
    height: 70px;
    background: #ffffffcc;
    border-radius: 12px;
    box-shadow: 0 3px 7px rgba(0,0,0,0.15);
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    overflow: visible;
    cursor: pointer;
    transition: transform 0.3s ease;
  }
  .cell.empty {
    background: transparent;
    cursor: default;
  }
  .cell.forbidden {
    filter: grayscale(100%) brightness(0.7);
    cursor: not-allowed;
    position: relative;
  }
  .cell.forbidden::after {
    content: "✕";
    position: absolute;
    top: 5px;
    right: 7px;
    font-size: 22px;
    color: #d32f2f;
  }
  .cell.selected {
    outline: 3px solid #00796b;
  }
  .cell img {
    width: 48px;
    height: 48px;
    pointer-events: none;
    user-select: none;
    position: relative;
    z-index: 1;
  }
  #scoreboard {
    font-size: 18px;
    margin-top: 10px;
    color: #004d40;
  }
  #nextBtn {
    margin-top: 18px;
    padding: 10px 24px;
    background: #00796b;
    color: white;
    border: none;
    border-radius: 10px;
    font-size: 16px;
    cursor: pointer;
    user-select: none;
  }
  #nextBtn:disabled {
    background: #ccc;
    cursor: not-allowed;
  }
</style>
</head>
<body>

<h1>Jeu Fruits/Légumes - Descente Animée & Interdits</h1>
<div id="objective"></div>
<div id="forbidden"></div>
<div id="grid"></div>
<div id="scoreboard"></div>
<button id="nextBtn" disabled>Valider et Manche Suivante</button>

<script>
const fruitsLegumes = [
  {name: "Ananas", img: "https://upload.wikimedia.org/wikipedia/commons/c/cb/Pineapple_and_cross_section.jpg"},
  {name: "Fraise", img: "https://upload.wikimedia.org/wikipedia/commons/2/29/PerfectStrawberry.jpg"},
  {name: "Banane", img: "https://upload.wikimedia.org/wikipedia/commons/8/8a/Banana-Single.jpg"},
  {name: "Carotte", img: "https://upload.wikimedia.org/wikipedia/commons/7/7e/Carrot_on_white_background.jpg"},
  {name: "Tomate", img: "https://upload.wikimedia.org/wikipedia/commons/8/88/Bright_red_tomato_and_cross_section02.jpg"},
  {name: "Pomme", img: "https://upload.wikimedia.org/wikipedia/commons/1/15/Red_Apple.jpg"},
];

const objectifs = [
  {Ananas: 5, Fraise: 3, Banane: 4},
  {Ananas: 6, Fraise: 2, Banane: 5},
  {Ananas: 7, Fraise: 4, Banane: 3},
  {Ananas: 8, Fraise: 5, Banane: 4},
  {Ananas: 9, Fraise: 6, Banane: 5},
  {Ananas: 10, Fraise: 7, Banane: 6},
  {Ananas: 11, Fraise: 8, Banane: 7},
  {Ananas: 12, Fraise: 9, Banane: 8},
  {Ananas: 13, Fraise: 10, Banane: 9},
  {Ananas: 14, Fraise: 11, Banane: 10},
];

const ROWS = 6;
const COLS = 6;

const grid = document.getElementById('grid');
const objectiveDiv = document.getElementById('objective');
const forbiddenDiv = document.getElementById('forbidden');
const scoreboard = document.getElementById('scoreboard');
const nextBtn = document.getElementById('nextBtn');

let board = [];
let selectedCells = new Set();
let currentRound = 0;
let totalScore = 0;
let forbiddenFruit = null;

function randomItem() {
  return fruitsLegumes[Math.floor(Math.random() * fruitsLegumes.length)];
}

function initBoard() {
  board = [];
  for(let r=0; r<ROWS; r++) {
    let row = [];
    for(let c=0; c<COLS; c++) {
      row.push(randomItem());
    }
    board.push(row);
  }
}

function renderBoard() {
  grid.innerHTML = '';
  for(let r=0; r<ROWS; r++) {
    for(let c=0; c<COLS; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.row = r;
      cell.dataset.col = c;

      const item = board[r][c];
      if(item) {
        const img = document.createElement('img');
        img.src = item.img;
        img.alt = item.name;
        cell.dataset.name = item.name;
        cell.appendChild(img);
      } else {
        cell.classList.add('empty');
        cell.dataset.name = '';
      }
      if(item && item.name === forbiddenFruit) {
        cell.classList.add('forbidden');
      }
      grid.appendChild(cell);
    }
  }
}

function showObjective() {
  const obj = objectifs[currentRound];
  let txt = `Objectif : `;
  for(let key in obj) {
    txt += `${obj[key]} ${key}${obj[key]>1?'s':''}  `;
  }
  objectiveDiv.textContent = txt;
}

function showForbidden() {
  forbiddenDiv.textContent = `Fruit/Légume interdit ce tour : ${forbiddenFruit}`;
}

function updateForbiddenFruit() {
  forbiddenFruit = fruitsLegumes[currentRound % fruitsLegumes.length].name;
}

function canSelect(cell) {
  if(cell.classList.contains('empty') || cell.classList.contains('forbidden')) return false;
  if(selectedCells.has(cell)) return false;
  return true;
}

function selectCell(cell) {
  if(!canSelect(cell)) return;
  selectedCells.add(cell);
  cell.classList.add('selected');
  nextBtn.disabled = false;
}

function deselectAll() {
  selectedCells.forEach(c => c.classList.remove('selected'));
  selectedCells.clear();
  nextBtn.disabled = true;
}

function removeSelectedCells() {
  selectedCells.forEach(cell => {
    const r = +cell.dataset.row;
    const c = +cell.dataset.col;
    board[r][c] = null;
  });
}

function gravity() {
  // Met à jour le board en déplaçant les fruits vers le bas dans le tableau
  for(let c=0; c<COLS; c++) {
    for(let r=ROWS-1; r>=0; r--) {
      if(board[r][c] === null) {
        for(let rr=r-1; rr>=0; rr--) {
          if(board[rr][c] !== null) {
            board[r][c] = board[rr][c];
            board[rr][c] = null;
            break;
          }
        }
      }
    }
  }
}

function animateFall(callback) {
  // Animation descendante des images sur la grille
  // Pour chaque colonne, on calcule combien de cases vides il y a sous chaque fruit sélectionné ou déplacé
  const cells = Array.from(grid.children);
  const positions = cells.map(cell => cell.getBoundingClientRect());

  // Clone les images pour animation en position absolue
  const animations = [];

  for(let c=0; c<COLS; c++) {
    // Pour chaque colonne, calculer combien de cases vides sous chaque fruit
    let emptyBelow = new Array(ROWS).fill(0);
    // Compter cases vides sous chaque case
    for(let r=ROWS-2; r>=0; r--) {
      if(board[r][c] !== null) {
        let count = 0;
        for(let rr=r+1; rr<ROWS; rr++) {
          if(board[rr][c] === null) count++;
          else break;
        }
        emptyBelow[r] = count;
      }
    }

    for(let r=0; r<ROWS; r++) {
      const idx = r * COLS + c;
      const cell = cells[idx];
      const img = cell.querySelector('img');
      if(img && emptyBelow[r] > 0) {
        const rect = cell.getBoundingClientRect();
        const moveY = emptyBelow[r] * (rect.height + 8); // 8 = grid gap

        // Créer clone pour animation
        const clone = img.cloneNode(true);
        clone.style.position = 'absolute';
        clone.style.left = rect.left + 'px';
        clone.style.top = rect.top + 'px';
        clone.style.transition = 'transform 0.5s ease';
        clone.style.zIndex = 1000;
        document.body.appendChild(clone);

        // Cacher image originale pour éviter doublon visuel pendant animation
        img.style.visibility = 'hidden';

        // Anime la descente
        requestAnimationFrame(() => {
          clone.style.transform = `translateY(${moveY}px)`;
        });

        animations.push({clone, originalImg: img});
      }
    }
  }

  // Après 600ms, nettoyer et callback
  setTimeout(() => {
    animations.forEach(({clone, originalImg}) => {
      clone.remove();
      // Original sera réaffiché au prochain renderBoard
      originalImg.style.visibility = 'visible';
    });
    callback();
  }, 600);
}

function calculateScore() {
  const obj = objectifs[currentRound];
  const counts = {};
  selectedCells.forEach(cell => {
    const name = cell.dataset.name;
    counts[name] = (counts[name]||0) + 1;
  });

  let score = 0;
  for(let key in obj) {
    const val = counts[key] || 0;
    score += Math.min(val, obj[key]);
  }
  return score;
}

function showScore() {
  const score = calculateScore();
  scoreboard.textContent = `Score manche ${currentRound+1} : ${score} / Objectif possible`;
  totalScore += score;
}

function startRound() {
  updateForbiddenFruit();
  showObjective();
  showForbidden();
  renderBoard();
  deselectAll();
  scoreboard.textContent = '';
  nextBtn.disabled = true;
}

grid.addEventListener('pointerdown', e => {
  if(e.target.closest('.cell')) {
    const cell = e.target.closest('.cell');
    selectCell(cell);
  }
});

nextBtn.addEventListener('click', () => {
  if(selectedCells.size === 0) return;
  showScore();
  animateFall(() => {
    removeSelectedCells();
    gravity();
    renderBoard();
    deselectAll();
    currentRound++;
    if(currentRound >= objectifs.length) {
      alert(`Fin du jeu ! Score total : ${totalScore}`);
      currentRound = 0;
      totalScore = 0;
      initBoard();
    }
    startRound();
  });
});

// Initialisation
initBoard();
startRound();

</script>

</body>
</html>
